<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACS Feature Performance Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 30px;
            font-weight: 300;
            font-size: 2.5em;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        select, button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            border-color: #3498db;
            box-shadow: 0 2px 5px rgba(52, 152, 219, 0.2);
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            font-weight: 600;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: 700;
            margin: 10px 0;
        }
        
        .metric-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .metric-change {
            font-size: 18px;
            font-weight: 600;
            padding: 5px 10px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .positive {
            color: #27ae60;
            background: #e8f8f5;
        }
        
        .negative {
            color: #e74c3c;
            background: #fadbd8;
        }
        
        .neutral {
            color: #95a5a6;
            background: #ecf0f1;
        }
        
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            position: relative;
        }
        
        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        canvas {
            max-height: 400px;
        }
        
        .heatmap-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        
        .heatmap {
            min-width: 600px;
        }
        
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 10px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
        
        .table-wrapper {
            overflow-x: auto;
            margin-top: 20px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        
        th:hover {
            background-color: #e9ecef;
        }
        
        .sub-header th {
            background-color: #e9ecef;
            font-size: 12px;
            font-weight: 500;
        }
        
        .sort-icon {
            font-size: 10px;
            color: #999;
            margin-left: 5px;
        }
        
        tbody tr:hover {
            background-color: #f8f9fa;
        }
        
        tbody tr:nth-child(even) {
            background-color: #fafbfc;
        }
        
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .table-search {
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 250px;
            font-size: 14px;
        }
        
        .export-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .export-btn:hover {
            background: #229954;
        }
        
        .value-positive {
            color: #27ae60;
            font-weight: 600;
        }
        
        .value-negative {
            color: #e74c3c;
            font-weight: 600;
        }
        
        .value-neutral {
            color: #7f8c8d;
        }
        
        .no-data {
            color: #bdc3c7;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ACS Feature Performance Dashboard</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Market</label>
                <select id="marketFilter">
                    <option value="all">All Markets</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Feature</label>
                <select id="featureFilter">
                    <option value="all">All Features</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Metric View</label>
                <select id="metricView">
                    <option value="variance">Variance (%)</option>
                    <option value="absolute">Absolute Values</option>
                    <option value="indexed">Indexed (Pre = 100)</option>
                </select>
            </div>
            
            <button onclick="resetFilters()">Reset Filters</button>
        </div>
        
        <div class="metrics-grid" id="metricsGrid"></div>
        
        <div class="chart-container">
            <div class="chart-title">Feature Performance Comparison</div>
            <canvas id="butterflyChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">Market Performance by Metric</div>
            <canvas id="groupedBarChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">Detailed Performance Table</div>
            <div class="table-controls">
                <button onclick="exportTable()" class="export-btn">Export to CSV</button>
                <input type="text" id="tableSearch" placeholder="Search table..." class="table-search">
            </div>
            <div class="table-wrapper">
                <table id="performanceTable">
                    <thead>
                        <tr>
                            <th onclick="sortTable(0)">Market <span class="sort-icon">⇅</span></th>
                            <th onclick="sortTable(1)">Feature <span class="sort-icon">⇅</span></th>
                            <th onclick="sortTable(2)">Go-Live Date <span class="sort-icon">⇅</span></th>
                            <th colspan="3">Principal Lending</th>
                            <th colspan="3">Transaction Count</th>
                            <th colspan="3">Transaction Size</th>
                            <th colspan="3">Recovery Rate</th>
                        </tr>
                        <tr class="sub-header">
                            <th></th>
                            <th></th>
                            <th></th>
                            <th>Pre</th>
                            <th>Post</th>
                            <th>Change %</th>
                            <th>Pre</th>
                            <th>Post</th>
                            <th>Change %</th>
                            <th>Pre</th>
                            <th>Post</th>
                            <th>Change %</th>
                            <th>Pre</th>
                            <th>Post</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="heatmap-container">
            <div class="chart-title">Performance Heatmap (% Change)</div>
            <div id="heatmap" class="heatmap"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #d73027"></div>
                    <span>Negative</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fee08b"></div>
                    <span>Neutral</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #1a9850"></div>
                    <span>Positive</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Sample data based on the Excel file structure
        const rawData = [
            {
                market: "Airtel Madagascar",
                feature: "ACS Bundles config",
                metrics: {
                    lending: { pre: 100, post: 105, variance: 0.05 },
                    tranxCount: { pre: 5, post: 5.2, variance: 0.04 },
                    tranxSize: { pre: 13.22, post: 14.2, variance: 0.074 },
                    recovery: { pre: 0.9223, post: 0.9335, variance: 0.0112 }
                }
            },
            {
                market: "Airtel Madagascar",
                feature: "ACS Collections config",
                goLiveDate: "2025-04-10",
                metrics: {
                    lending: { pre: 54028616, post: 66705478, variance: 0.235 },
                    tranxCount: { pre: 3.26, post: 3.61, variance: 0.107 },
                    tranxSize: { pre: 623, post: 573, variance: -0.080 },
                    recovery: { pre: 0.952, post: 0.9736, variance: 0.0216 }
                }
            },
            {
                market: "Airtel Madagascar",
                feature: "ACS Fee config",
                goLiveDate: "2025-04-12",
                metrics: {
                    lending: { pre: 201695969, post: 234810076, variance: 0.164 },
                    tranxCount: { pre: 2.45, post: 2.64, variance: 0.078 },
                    tranxSize: { pre: 675.23, post: 695.42, variance: 0.030 },
                    recovery: { pre: 0.965, post: 0.971, variance: 0.006 }
                }
            },
            {
                market: "Airtel Uganda",
                feature: "ACS Collections config",
                goLiveDate: "2025-05-01",
                metrics: {
                    lending: { pre: 321697878, post: 441469285, variance: 0.372 },
                    tranxCount: { pre: 1.03, post: 1.05, variance: 0.019 },
                    tranxSize: { pre: 695, post: 715, variance: 0.029 },
                    recovery: { pre: 0.9741, post: 0.9785, variance: 0.0044 }
                }
            },
            {
                market: "Airtel Uganda",
                feature: "ACS denom config",
                goLiveDate: "2025-05-10",
                metrics: {
                    lending: { pre: 52033651, post: 55236668, variance: 0.062 },
                    tranxCount: { pre: 3.15, post: 3.02, variance: -0.041 },
                    tranxSize: { pre: 591.16, post: 602.35, variance: 0.019 },
                    recovery: { pre: 0.9835, post: 0.9816, variance: -0.0019 }
                }
            },
            {
                market: "Airtel Niger",
                feature: "ACS Collections config",
                goLiveDate: "2025-03-15",
                metrics: {
                    lending: { pre: 233695929, post: 523695929, variance: 1.241 },
                    tranxCount: { pre: 9.97, post: 9.37, variance: -0.060 },
                    tranxSize: { pre: 432.5, post: 367.6, variance: -0.150 },
                    recovery: { pre: 0.9858, post: 0.9653, variance: -0.0205 }
                }
            },
            {
                market: "Airtel Kenya",
                feature: "ACS Product rules config",
                goLiveDate: "2025-04-20",
                metrics: {
                    lending: { pre: 561955442, post: 596552717, variance: 0.062 },
                    tranxCount: { pre: 6.7, post: 7.01, variance: 0.046 },
                    tranxSize: { pre: 525.8, post: 615.2, variance: 0.170 },
                    recovery: { pre: 0.945, post: 0.952, variance: 0.007 }
                }
            }
        ];

        // Initialize charts
        let butterflyChart, groupedBarChart;
        
        // Populate filters
        function populateFilters() {
            const markets = [...new Set(rawData.map(d => d.market))];
            const features = [...new Set(rawData.map(d => d.feature))];
            
            const marketSelect = document.getElementById('marketFilter');
            markets.forEach(market => {
                const option = document.createElement('option');
                option.value = market;
                option.textContent = market;
                marketSelect.appendChild(option);
            });
            
            const featureSelect = document.getElementById('featureFilter');
            features.forEach(feature => {
                const option = document.createElement('option');
                option.value = feature;
                option.textContent = feature;
                featureSelect.appendChild(option);
            });
        }
        
        // Filter data based on selections
        function getFilteredData() {
            const marketFilter = document.getElementById('marketFilter').value;
            const featureFilter = document.getElementById('featureFilter').value;
            
            return rawData.filter(d => {
                const marketMatch = marketFilter === 'all' || d.market === marketFilter;
                const featureMatch = featureFilter === 'all' || d.feature === featureFilter;
                return marketMatch && featureMatch;
            });
        }
        
        // Update metric cards
        function updateMetricCards() {
            const filteredData = getFilteredData();
            const metricsGrid = document.getElementById('metricsGrid');
            
            if (filteredData.length === 0) {
                metricsGrid.innerHTML = '<p>No data available for selected filters</p>';
                return;
            }
            
            // Calculate aggregated metrics
            const metrics = {
                lending: { pre: 0, post: 0, count: 0 },
                tranxCount: { pre: 0, post: 0, count: 0 },
                tranxSize: { pre: 0, post: 0, count: 0 },
                recovery: { pre: 0, post: 0, count: 0 }
            };
            
            filteredData.forEach(d => {
                Object.keys(metrics).forEach(key => {
                    if (d.metrics[key]) {
                        metrics[key].pre += d.metrics[key].pre;
                        metrics[key].post += d.metrics[key].post;
                        metrics[key].count++;
                    }
                });
            });
            
            // Create metric cards
            const metricConfigs = [
                { key: 'lending', label: 'Avg Principal Lending', format: 'currency' },
                { key: 'tranxCount', label: 'Avg Transaction Count', format: 'number' },
                { key: 'tranxSize', label: 'Avg Transaction Size', format: 'currency' },
                { key: 'recovery', label: 'Avg Recovery Rate', format: 'percentage' }
            ];
            
            metricsGrid.innerHTML = metricConfigs.map(config => {
                const metric = metrics[config.key];
                if (metric.count === 0) return '';
                
                const avgPre = metric.pre / metric.count;
                const avgPost = metric.post / metric.count;
                const variance = ((avgPost - avgPre) / avgPre) * 100;
                
                let valueDisplay;
                if (config.format === 'currency') {
                    valueDisplay = avgPost > 1000000 ? 
                        `${(avgPost / 1000000).toFixed(1)}M` : 
                        avgPost.toFixed(0);
                } else if (config.format === 'percentage') {
                    valueDisplay = `${(avgPost * 100).toFixed(1)}%`;
                } else {
                    valueDisplay = avgPost.toFixed(2);
                }
                
                const changeClass = variance > 0 ? 'positive' : variance < 0 ? 'negative' : 'neutral';
                const changeSymbol = variance > 0 ? '+' : '';
                
                return `
                    <div class="metric-card">
                        <div class="metric-label">${config.label}</div>
                        <div class="metric-value">${valueDisplay}</div>
                        <div class="metric-change ${changeClass}">
                            ${changeSymbol}${variance.toFixed(1)}%
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update butterfly chart
        function updateButterflyChart() {
            const filteredData = getFilteredData();
            const ctx = document.getElementById('butterflyChart').getContext('2d');
            
            if (butterflyChart) {
                butterflyChart.destroy();
            }
            
            const labels = filteredData.map(d => `${d.market} - ${d.feature}`.substring(0, 30) + '...');
            const metricView = document.getElementById('metricView').value;
            
            const datasets = [];
            const metrics = ['lending', 'tranxCount', 'tranxSize', 'recovery'];
            const metricLabels = ['Lending', 'Transaction Count', 'Transaction Size', 'Recovery Rate'];
            const colors = ['#3498db', '#e74c3c', '#f39c12', '#27ae60'];
            
            metrics.forEach((metric, index) => {
                let data;
                if (metricView === 'variance') {
                    data = filteredData.map(d => d.metrics[metric] ? d.metrics[metric].variance * 100 : 0);
                } else if (metricView === 'indexed') {
                    data = filteredData.map(d => {
                        if (d.metrics[metric]) {
                            return (d.metrics[metric].post / d.metrics[metric].pre) * 100;
                        }
                        return 100;
                    });
                } else {
                    data = filteredData.map(d => d.metrics[metric] ? d.metrics[metric].post : 0);
                }
                
                datasets.push({
                    label: metricLabels[index],
                    data: data,
                    backgroundColor: colors[index] + '80',
                    borderColor: colors[index],
                    borderWidth: 2
                });
            });
            
            butterflyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (metricView === 'variance' || metricView === 'indexed') {
                                        label += context.parsed.y.toFixed(1) + '%';
                                    } else {
                                        label += context.parsed.y.toLocaleString();
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Feature-Market Combination'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: metricView === 'variance' ? 'Change (%)' : 
                                      metricView === 'indexed' ? 'Index (Pre = 100)' : 'Value'
                            }
                        }
                    }
                }
            });
        }
        
        // Update grouped bar chart for market performance
        function updateGroupedBarChart() {
            const ctx = document.getElementById('groupedBarChart').getContext('2d');
            
            if (groupedBarChart) {
                groupedBarChart.destroy();
            }
            
            // Aggregate performance by market
            const marketMetrics = {};
            const filteredData = getFilteredData();
            
            filteredData.forEach(item => {
                if (!marketMetrics[item.market]) {
                    marketMetrics[item.market] = {
                        lending: { total: 0, count: 0 },
                        tranxCount: { total: 0, count: 0 },
                        tranxSize: { total: 0, count: 0 },
                        recovery: { total: 0, count: 0 }
                    };
                }
                
                Object.keys(item.metrics).forEach(metric => {
                    if (item.metrics[metric] && item.metrics[metric].variance !== undefined) {
                        marketMetrics[item.market][metric].total += item.metrics[metric].variance;
                        marketMetrics[item.market][metric].count++;
                    }
                });
            });
            
            const markets = Object.keys(marketMetrics);
            const metrics = ['lending', 'tranxCount', 'tranxSize', 'recovery'];
            const metricLabels = {
                'lending': 'Avg Lending Change %',
                'tranxCount': 'Avg Tx Count Change %',
                'tranxSize': 'Avg Tx Size Change %',
                'recovery': 'Avg Recovery Change'
            };
            
            const datasets = metrics.map((metric, index) => {
                const colors = ['#3498db', '#e74c3c', '#f39c12', '#27ae60'];
                const data = markets.map(market => {
                    const m = marketMetrics[market][metric];
                    if (m.count === 0) return 0;
                    const avg = m.total / m.count;
                    return metric === 'recovery' ? avg * 100 : avg * 100; // Convert to percentage
                });
                
                return {
                    label: metricLabels[metric],
                    data: data,
                    backgroundColor: colors[index] + 'CC',
                    borderColor: colors[index],
                    borderWidth: 1
                };
            });
            
            groupedBarChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: markets,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: false
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                padding: 15
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.parsed.y;
                                    if (context.datasetIndex === 3) { // Recovery rate
                                        label += value.toFixed(2) + ' pp';
                                    } else {
                                        label += value.toFixed(1) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Markets'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Average Change (%)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update performance table
        function updatePerformanceTable() {
            const tableBody = document.getElementById('tableBody');
            const filteredData = getFilteredData();
            
            tableBody.innerHTML = filteredData.map(item => {
                const formatValue = (value, isLarge) => {
                    if (value === undefined || value === null) return '<span class="no-data">-</span>';
                    if (isLarge && value > 1000000) {
                        return (value / 1000000).toFixed(1) + 'M';
                    } else if (isLarge && value > 1000) {
                        return (value / 1000).toFixed(1) + 'K';
                    }
                    return typeof value === 'number' ? value.toFixed(2) : value;
                };
                
                const formatChange = (variance, isPercentage = true) => {
                    if (variance === undefined || variance === null) return '<span class="no-data">-</span>';
                    const value = isPercentage ? (variance * 100).toFixed(1) : variance.toFixed(4);
                    const cssClass = variance > 0 ? 'value-positive' : variance < 0 ? 'value-negative' : 'value-neutral';
                    const symbol = variance > 0 ? '+' : '';
                    return `<span class="${cssClass}">${symbol}${value}${isPercentage ? '%' : ''}</span>`;
                };
                
                const m = item.metrics;
                return `
                    <tr>
                        <td>${item.market}</td>
                        <td>${item.feature}</td>
                        <td>${item.goLiveDate ? new Date(item.goLiveDate).toLocaleDateString() : '<span class="no-data">-</span>'}</td>
                        <td>${formatValue(m.lending?.pre, true)}</td>
                        <td>${formatValue(m.lending?.post, true)}</td>
                        <td>${formatChange(m.lending?.variance)}</td>
                        <td>${formatValue(m.tranxCount?.pre)}</td>
                        <td>${formatValue(m.tranxCount?.post)}</td>
                        <td>${formatChange(m.tranxCount?.variance)}</td>
                        <td>${formatValue(m.tranxSize?.pre)}</td>
                        <td>${formatValue(m.tranxSize?.post)}</td>
                        <td>${formatChange(m.tranxSize?.variance)}</td>
                        <td>${formatValue(m.recovery?.pre)}</td>
                        <td>${formatValue(m.recovery?.post)}</td>
                        <td>${formatChange(m.recovery?.variance, false)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Table search functionality
        document.getElementById('tableSearch').addEventListener('keyup', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const rows = document.querySelectorAll('#tableBody tr');
            
            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                row.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        });
        
        // Sort table functionality
        let sortDirection = {};
        function sortTable(columnIndex) {
            const table = document.getElementById('performanceTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            sortDirection[columnIndex] = !sortDirection[columnIndex];
            
            rows.sort((a, b) => {
                let aValue = a.cells[columnIndex].textContent.trim();
                let bValue = b.cells[columnIndex].textContent.trim();
                
                // Remove special characters and parse numbers
                aValue = aValue.replace(/[%+,MK]/g, '');
                bValue = bValue.replace(/[%+,MK]/g, '');
                
                if (!isNaN(aValue) && !isNaN(bValue)) {
                    aValue = parseFloat(aValue) || 0;
                    bValue = parseFloat(bValue) || 0;
                } else if (columnIndex === 2) { // Date column
                    aValue = new Date(aValue) || new Date(0);
                    bValue = new Date(bValue) || new Date(0);
                }
                
                if (sortDirection[columnIndex]) {
                    return aValue > bValue ? 1 : -1;
                } else {
                    return aValue < bValue ? 1 : -1;
                }
            });
            
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        }
        
        // Export table to CSV
        function exportTable() {
            const table = document.getElementById('performanceTable');
            const rows = Array.from(table.querySelectorAll('tr'));
            
            const csv = rows.map(row => {
                const cells = Array.from(row.querySelectorAll('th, td'));
                return cells.map(cell => {
                    let text = cell.textContent.trim();
                    // Handle cells with commas or quotes
                    if (text.includes(',') || text.includes('"')) {
                        text = '"' + text.replace(/"/g, '""') + '"';
                    }
                    return text;
                }).join(',');
            }).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('hidden', '');
            a.setAttribute('href', url);
            a.setAttribute('download', 'acs_performance_data.csv');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // Create heatmap
        function createHeatmap() {
            const container = d3.select("#heatmap");
            container.selectAll("*").remove();
            
            const margin = {top: 50, right: 50, bottom: 100, left: 150};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Prepare data for heatmap
            const features = [...new Set(rawData.map(d => d.feature))];
            const markets = [...new Set(rawData.map(d => d.market))];
            
            const heatmapData = [];
            markets.forEach((market, i) => {
                features.forEach((feature, j) => {
                    const item = rawData.find(d => d.market === market && d.feature === feature);
                    if (item && item.metrics.lending) {
                        heatmapData.push({
                            market: market,
                            feature: feature,
                            value: item.metrics.lending.variance * 100,
                            x: j,
                            y: i
                        });
                    }
                });
            });
            
            // Scales
            const x = d3.scaleBand()
                .range([0, width])
                .domain(features)
                .padding(0.05);
            
            const y = d3.scaleBand()
                .range([height, 0])
                .domain(markets)
                .padding(0.05);
            
            const colorScale = d3.scaleSequential()
                .interpolator(d3.interpolateRdYlGn)
                .domain([-50, 50]);
            
            // Create cells
            svg.selectAll()
                .data(heatmapData)
                .enter()
                .append("rect")
                .attr("x", d => x(d.feature))
                .attr("y", d => y(d.market))
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", d => colorScale(d.value))
                .style("stroke", "white")
                .style("stroke-width", 2)
                .on("mouseover", function(event, d) {
                    const tooltip = d3.select("#tooltip");
                    tooltip.style("opacity", 1)
                        .html(`${d.market}<br>${d.feature}<br>Change: ${d.value.toFixed(1)}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    d3.select("#tooltip").style("opacity", 0);
                });
            
            // Add value labels
            svg.selectAll()
                .data(heatmapData)
                .enter()
                .append("text")
                .attr("x", d => x(d.feature) + x.bandwidth() / 2)
                .attr("y", d => y(d.market) + y.bandwidth() / 2)
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .style("fill", d => Math.abs(d.value) > 30 ? "white" : "black")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .text(d => d.value.toFixed(0) + "%");
            
            // X axis
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");
            
            // Y axis
            svg.append("g")
                .call(d3.axisLeft(y));
        }
        
        // Reset filters
        function resetFilters() {
            document.getElementById('marketFilter').value = 'all';
            document.getElementById('featureFilter').value = 'all';
            document.getElementById('metricView').value = 'variance';
            updateDashboard();
        }
        
        // Update entire dashboard
        function updateDashboard() {
            updateMetricCards();
            updateButterflyChart();
            updateGroupedBarChart();
            updatePerformanceTable();
            createHeatmap();
        }
        
        // Event listeners
        document.getElementById('marketFilter').addEventListener('change', updateDashboard);
        document.getElementById('featureFilter').addEventListener('change', updateDashboard);
        document.getElementById('metricView').addEventListener('change', updateDashboard);
        
        // Initialize
        populateFilters();
        updateDashboard();
    </script>
</body>
</html>